<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>netket.sampler.metropolis &#8212; netket v3.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jumbo-style.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/all.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/rtd_theme.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/rtd_theme.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html"><span><img src="../../../_static/logonav.png"></span>
          NetKet</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../getting_started.html">Get Started</a></li>
                <li><a href="../../../docs/getting_started.html">Documentation</a></li>
                <li><a href="../../../tutorials.html">Tutorials</a></li>
                <li><a href="../../../citing.html">Citing NetKet</a></li>
                <li><a href="../../../about.html">About</a></li>
                <li><a href="https://github.com/netket/netket"><i class="fab fa-github" aria-hidden="true"></i></a></li>
                <li><a href="https://twitter.com/NetKetOrg"><i class="fab fa-twitter" aria-hidden="true"></i></a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for netket.sampler.metropolis</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2021 The NetKet Authors - All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#    http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span>

<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>
<span class="kn">from</span> <span class="nn">jax.experimental</span> <span class="kn">import</span> <span class="n">loops</span>

<span class="kn">from</span> <span class="nn">flax</span> <span class="kn">import</span> <span class="n">struct</span>

<span class="kn">from</span> <span class="nn">netket.hilbert</span> <span class="kn">import</span> <span class="n">AbstractHilbert</span>
<span class="kn">from</span> <span class="nn">netket.utils</span> <span class="kn">import</span> <span class="n">n_nodes</span>
<span class="kn">from</span> <span class="nn">netket.stats</span> <span class="kn">import</span> <span class="n">sum_inplace</span>
<span class="kn">from</span> <span class="nn">netket.utils.types</span> <span class="kn">import</span> <span class="n">PyTree</span><span class="p">,</span> <span class="n">PRNGKeyT</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">Sampler</span><span class="p">,</span> <span class="n">SamplerState</span>


<div class="viewcode-block" id="MetropolisRule"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisRule.html#netket.sampler.MetropolisRule">[docs]</a><span class="nd">@struct</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">MetropolisRule</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Transition rules of Metropolis, such as Local, Exchange, Hamiltonian</span>
<span class="sd">    and several others.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MetropolisRule.init_state"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisRule.html#netket.sampler.MetropolisRule.init_state">[docs]</a>    <span class="k">def</span> <span class="nf">init_state</span><span class="p">(</span>
        <span class="n">rule</span><span class="p">,</span>
        <span class="n">sampler</span><span class="p">:</span> <span class="n">Sampler</span><span class="p">,</span>
        <span class="n">machine</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">PyTree</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">PRNGKeyT</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialises the optional internal state of the Metropolis Sampler Transition</span>
<span class="sd">        Rule.</span>

<span class="sd">        The provided key is unique and does not need to be splitted.</span>
<span class="sd">        It should return an immutable datastructure.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            sampler: The Metropolis sampler</span>
<span class="sd">            machine: The forward evaluation function of the model, accepting PyTrees of parameters and inputs.</span>
<span class="sd">            params: The dict of variables needed to evaluate the model.</span>
<span class="sd">            key: A Jax PRNGKey rng state.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An Optional State.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MetropolisRule.reset"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisRule.html#netket.sampler.MetropolisRule.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span>
        <span class="n">rule</span><span class="p">,</span>
        <span class="n">sampler</span><span class="p">:</span> <span class="n">Sampler</span><span class="p">,</span>
        <span class="n">machine</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">PyTree</span><span class="p">,</span>
        <span class="n">sampler_state</span><span class="p">:</span> <span class="n">SamplerState</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the internal state of the Metropolis Sampler Transition Rule.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            sampler: The Metropolis sampler</span>
<span class="sd">            machine: The forward evaluation function of the model, accepting PyTrees of parameters and inputs.</span>
<span class="sd">            params: The dict of variables needed to evaluate the model.</span>
<span class="sd">            sampler_state: The current state of the sampler. Should not modify it.</span>

<span class="sd">        Returns:</span>
<span class="sd">           A new, resetted, state of the rule. This returns the same type of :py:meth:`sampler_state.rule_state` and might be None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sampler_state</span><span class="o">.</span><span class="n">rule_state</span></div>

<div class="viewcode-block" id="MetropolisRule.transition"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisRule.html#netket.sampler.MetropolisRule.transition">[docs]</a>    <span class="k">def</span> <span class="nf">transition</span><span class="p">(</span>
        <span class="n">rule</span><span class="p">,</span>
        <span class="n">sampler</span><span class="p">:</span> <span class="n">Sampler</span><span class="p">,</span>
        <span class="n">machine</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">PyTree</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">SamplerState</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">PRNGKeyT</span><span class="p">,</span>
        <span class="n">σ</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MetropolisRule.random_state"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisRule.html#netket.sampler.MetropolisRule.random_state">[docs]</a>    <span class="k">def</span> <span class="nf">random_state</span><span class="p">(</span>
        <span class="n">rule</span><span class="p">,</span>
        <span class="n">sampler</span><span class="p">:</span> <span class="n">Sampler</span><span class="p">,</span>
        <span class="n">machine</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">PyTree</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">SamplerState</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">PRNGKeyT</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random state compatible with this rule.</span>

<span class="sd">        By default this calls :func:`netket.hilbert.random.random_state`.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            sampler: the sampler</span>
<span class="sd">            machine: the function to evaluate the model</span>
<span class="sd">            parameters: the parameters of the model</span>
<span class="sd">            state: the current sampler state</span>
<span class="sd">            key: the PRNGKey to use to generate the random state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sampler</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">sampler</span><span class="o">.</span><span class="n">n_batches</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sampler</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="MetropolisSamplerState"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisSamplerState.html#netket.sampler.MetropolisSamplerState">[docs]</a><span class="nd">@struct</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">MetropolisSamplerState</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    State for a metropolis sampler.</span>
<span class="sd">    Contains the current configuration, the rng state and the (optional)</span>
<span class="sd">    state of the transition rule.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">σ</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="sd">&quot;&quot;&quot;Current batch of configurations in the markov chain.&quot;&quot;&quot;</span>
    <span class="n">rng</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="sd">&quot;&quot;&quot;State of the random number generator (key, in jax terms).&quot;&quot;&quot;</span>
    <span class="n">rule_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;Optional state of a transition rule.&quot;&quot;&quot;</span>
    <span class="n">n_steps_proc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;Number of moves performed along the chains in this process since the last reset.&quot;&quot;&quot;</span>
    <span class="n">n_accepted_proc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;Number of accepted transitions among the chains in this process since the last reset.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">acceptance_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The percentage of accepted moves across all chains and MPI processes.</span>

<span class="sd">        The rate is computed since the last reset of the sampler.</span>
<span class="sd">        Will return None if no sampling has been performed since then.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_accepted</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span> <span class="o">*</span> <span class="mi">100</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Total number of moves performed across all processes since the last reset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_steps_proc</span> <span class="o">*</span> <span class="n">n_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_accepted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Total number of moves accepted across all processes since the last reset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sum_inplace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_accepted_proc</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">acc_string</span> <span class="o">=</span> <span class="s2">&quot;# accepted = </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">%), &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_accepted</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_ratio</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">acc_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;MetropolisNumpySamplerState(</span><span class="si">{</span><span class="n">acc_string</span><span class="si">}</span><span class="s2">rng state=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="si">}</span><span class="s2">)&quot;</span></div>


<div class="viewcode-block" id="MetropolisSampler"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisSampler.html#netket.sampler.MetropolisSampler">[docs]</a><span class="nd">@struct</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">MetropolisSampler</span><span class="p">(</span><span class="n">Sampler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metropolis-Hastings sampler for an Hilbert space according to a specific transition rule.</span>

<span class="sd">    The transition rule is used to generate a proposed state :math:`s^\prime`, starting from the</span>
<span class="sd">    current state :math:`s`. The move is accepted with probability</span>

<span class="sd">    .. math::</span>

<span class="sd">        A(s \\rightarrow s^\\prime) = \\mathrm{min} \\left( 1,\\frac{P(s^\\prime)}{P(s)} F(e^{L(s,s^\\prime)}) \\right) ,</span>

<span class="sd">    where the probability being sampled from is :math:`P(s)=|M(s)|^p. Here ::math::`M(s)` is a</span>
<span class="sd">    user-provided function (the machine), :math:`p` is also user-provided with default value :math:`p=2`,</span>
<span class="sd">    and :math:`L(s,s^\prime)` is a suitable correcting factor computed by the transition kernel.</span>

<span class="sd">    The dtype of the sampled states can be chosen.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rule</span><span class="p">:</span> <span class="n">MetropolisRule</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;The metropolis transition rule.&quot;&quot;&quot;</span>
    <span class="n">n_sweeps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">pytree_node</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Number of sweeps for each step along the chain. Defaults to number of sites in hilbert space.&quot;&quot;&quot;</span>
    <span class="n">reset_chain</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;If True resets the chain state when reset is called (every new sampling).&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MetropolisSampler.__init__"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisSampler.html#netket.sampler.MetropolisSampler.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hilbert</span><span class="p">:</span> <span class="n">AbstractHilbert</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">:</span> <span class="n">MetropolisRule</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">n_sweeps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reset_chain</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a Metropolis Sampler.</span>

<span class="sd">        Args:</span>
<span class="sd">            hilbert: The hilbert space to sample</span>
<span class="sd">            rule: A `MetropolisRule` to generate random transitions from a given state as</span>
<span class="sd">                    well as uniform random states.</span>
<span class="sd">            n_sweeps: The number of exchanges that compose a single sweep.</span>
<span class="sd">                    If None, sweep_size is equal to the number of degrees of freedom being sampled</span>
<span class="sd">                    (the size of the input vector s to the machine).</span>
<span class="sd">            reset_chain: If False the state configuration is not resetted when reset() is called.</span>
<span class="sd">            n_chains: The number of Markov Chain to be run in parallel on a single process.</span>
<span class="sd">            n_chains: The number of batches of the states to sample (default = 8)</span>
<span class="sd">            machine_pow: The power to which the machine should be exponentiated to generate the pdf (default = 2).</span>
<span class="sd">            dtype: The dtype of the statees sampled (default = np.float32).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_sweeps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_sweeps</span> <span class="o">=</span> <span class="n">hilbert</span><span class="o">.</span><span class="n">size</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;rule&quot;</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;n_sweeps&quot;</span><span class="p">,</span> <span class="n">n_sweeps</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;reset_chain&quot;</span><span class="p">,</span> <span class="n">reset_chain</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">hilbert</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__post_init__</span><span class="p">()</span>
        <span class="c1"># Validate the inputs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="p">,</span> <span class="n">MetropolisRule</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;rule must be a MetropolisRule.&quot;</span><span class="p">)</span>

        <span class="c1">#  Default value of n_sweeps</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sweeps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;n_sweeps&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_state</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key_state</span><span class="p">,</span> <span class="n">key_rule</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">rule_state</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">init_state</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">key_rule</span><span class="p">)</span>
        <span class="n">σ</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sampler</span><span class="o">.</span><span class="n">n_chains</span><span class="p">,</span> <span class="n">sampler</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sampler</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">state</span> <span class="o">=</span> <span class="n">MetropolisSamplerState</span><span class="p">(</span><span class="n">σ</span><span class="o">=</span><span class="n">σ</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">key_state</span><span class="p">,</span> <span class="n">rule_state</span><span class="o">=</span><span class="n">rule_state</span><span class="p">)</span>

        <span class="c1"># If we don&#39;t reset the chain at every sampling iteration, then reset it</span>
        <span class="c1"># now.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sampler</span><span class="o">.</span><span class="n">reset_chain</span><span class="p">:</span>
            <span class="n">key_state</span><span class="p">,</span> <span class="n">rng</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key_state</span><span class="p">)</span>
            <span class="n">σ</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">σ</span><span class="o">=</span><span class="n">σ</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">key_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">new_rng</span><span class="p">,</span> <span class="n">rng</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">rng</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sampler</span><span class="o">.</span><span class="n">reset_chain</span><span class="p">:</span>
            <span class="n">σ</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">σ</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">σ</span>

        <span class="n">rule_state</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">σ</span><span class="o">=</span><span class="n">σ</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">new_rng</span><span class="p">,</span> <span class="n">rule_state</span><span class="o">=</span><span class="n">rule_state</span><span class="p">,</span> <span class="n">n_steps_proc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_accepted_proc</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sample_next</span><span class="p">(</span><span class="n">sampler</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">new_rng</span><span class="p">,</span> <span class="n">rng</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">rng</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">loops</span><span class="o">.</span><span class="n">Scope</span><span class="p">()</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">rng</span>
            <span class="n">s</span><span class="o">.</span><span class="n">σ</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">σ</span>
            <span class="n">s</span><span class="o">.</span><span class="n">log_prob</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">machine_pow</span> <span class="o">*</span> <span class="n">machine</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">σ</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

            <span class="c1"># for logging</span>
            <span class="n">s</span><span class="o">.</span><span class="n">accepted</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">n_accepted_proc</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">n_sweeps</span><span class="p">):</span>
                <span class="c1"># 1 to propagate for next iteration, 1 for uniform rng and n_chains for transition kernel</span>
                <span class="n">s</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">key1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

                <span class="n">σp</span><span class="p">,</span> <span class="n">log_prob_correction</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">transition</span><span class="p">(</span>
                    <span class="n">sampler</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">key1</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">σ</span>
                <span class="p">)</span>
                <span class="n">proposal_log_prob</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">machine_pow</span> <span class="o">*</span> <span class="n">machine</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">σp</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

                <span class="n">uniform</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">n_chains</span><span class="p">,))</span>
                <span class="k">if</span> <span class="n">log_prob_correction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">do_accept</span> <span class="o">=</span> <span class="n">uniform</span> <span class="o">&lt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                        <span class="n">proposal_log_prob</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">log_prob</span> <span class="o">+</span> <span class="n">log_prob_correction</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">do_accept</span> <span class="o">=</span> <span class="n">uniform</span> <span class="o">&lt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">proposal_log_prob</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">log_prob</span><span class="p">)</span>

                <span class="c1"># do_accept must match ndim of proposal and state (which is 2)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">σ</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">do_accept</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">σp</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">σ</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">accepted</span> <span class="o">+=</span> <span class="n">do_accept</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="n">s</span><span class="o">.</span><span class="n">log_prob</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">do_accept</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">proposal_log_prob</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">log_prob</span>
                <span class="p">)</span>

            <span class="n">new_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">rng</span><span class="o">=</span><span class="n">new_rng</span><span class="p">,</span>
                <span class="n">σ</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">σ</span><span class="p">,</span>
                <span class="n">n_accepted_proc</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">accepted</span><span class="p">,</span>
                <span class="n">n_steps_proc</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">n_steps_proc</span> <span class="o">+</span> <span class="n">sampler</span><span class="o">.</span><span class="n">n_sweeps</span> <span class="o">*</span> <span class="n">sampler</span><span class="o">.</span><span class="n">n_chains</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">new_state</span><span class="p">,</span> <span class="n">new_state</span><span class="o">.</span><span class="n">σ</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="n">sampler</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;MetropolisSampler(&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  hilbert = </span><span class="si">{}</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">hilbert</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  rule = </span><span class="si">{}</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">rule</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  n_chains = </span><span class="si">{}</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">n_chains</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  machine_power = </span><span class="si">{}</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">machine_pow</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  reset_chain = </span><span class="si">{}</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">reset_chain</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  n_sweeps = </span><span class="si">{}</span><span class="s2">,&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">n_sweeps</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  dtype = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="n">sampler</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;MetropolisSampler(&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;rule = </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">rule</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;n_chains = </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">n_chains</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;machine_power = </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">machine_pow</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;n_sweeps = </span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">n_sweeps</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;dtype = </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">netket.utils</span> <span class="kn">import</span> <span class="n">wraps_legacy</span>
<span class="kn">from</span> <span class="nn">netket.legacy.machine</span> <span class="kn">import</span> <span class="n">AbstractMachine</span>

<span class="kn">from</span> <span class="nn">.rules</span> <span class="kn">import</span> <span class="n">LocalRule</span>
<span class="kn">from</span> <span class="nn">netket.legacy.sampler</span> <span class="kn">import</span> <span class="n">MetropolisLocal</span> <span class="k">as</span> <span class="n">LegacyMetropolisLocal</span>


<div class="viewcode-block" id="MetropolisLocal"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisLocal.html#netket.sampler.MetropolisLocal">[docs]</a><span class="nd">@wraps_legacy</span><span class="p">(</span><span class="n">LegacyMetropolisLocal</span><span class="p">,</span> <span class="s2">&quot;machine&quot;</span><span class="p">,</span> <span class="n">AbstractMachine</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">MetropolisLocal</span><span class="p">(</span><span class="n">hilbert</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MetropolisSampler</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sampler acting on one local degree of freedom.</span>

<span class="sd">    This sampler acts locally only on one local degree of freedom :math:`s_i`,</span>
<span class="sd">    and proposes a new state: :math:`s_1 \dots s^\prime_i \dots s_N`,</span>
<span class="sd">    where :math:`s^\prime_i \\neq s_i`.</span>

<span class="sd">    The transition probability associated to this</span>
<span class="sd">    sampler can be decomposed into two steps:</span>

<span class="sd">    1. One of the site indices :math:`i = 1\dots N` is chosen with uniform probability.</span>

<span class="sd">    2. Among all the possible (:math:`m`) values that :math:`s_i` can take,</span>
<span class="sd">    one of them is chosen with uniform probability.</span>

<span class="sd">    For example, in the case of spin :math:`1/2` particles, :math:`m=2`</span>
<span class="sd">    and the possible local values are :math:`s_i = -1,+1`.</span>
<span class="sd">    In this case then :class:`MetropolisLocal` is equivalent to flipping a random spin.</span>

<span class="sd">    In the case of bosons, with occupation numbers</span>
<span class="sd">    :math:`s_i = 0, 1, \dots n_{\mathrm{max}}`, :class:`MetropolisLocal`</span>
<span class="sd">    would pick a random local occupation number uniformly between :math:`0`</span>
<span class="sd">    and :math:`n_{\mathrm{max}}`.</span>

<span class="sd">    Args:</span>
<span class="sd">        hilbert: The hilbert space to sample</span>
<span class="sd">        n_chains: The number of Markov Chain to be run in parallel on a single process.</span>
<span class="sd">        n_sweeps: The number of exchanges that compose a single sweep.</span>
<span class="sd">                If None, sweep_size is equal to the number of degrees of freedom being sampled</span>
<span class="sd">                (the size of the input vector s to the machine).</span>
<span class="sd">        n_chains: The number of batches of the states to sample (default = 8)</span>
<span class="sd">        machine_pow: The power to which the machine should be exponentiated to generate the pdf (default = 2).</span>
<span class="sd">        dtype: The dtype of the statees sampled (default = np.float32).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">MetropolisSampler</span><span class="p">(</span><span class="n">hilbert</span><span class="p">,</span> <span class="n">LocalRule</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">.rules</span> <span class="kn">import</span> <span class="n">ExchangeRule</span>
<span class="kn">from</span> <span class="nn">netket.legacy.sampler</span> <span class="kn">import</span> <span class="n">MetropolisExchange</span> <span class="k">as</span> <span class="n">LegacyMetropolisExchange</span>


<div class="viewcode-block" id="MetropolisExchange"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisExchange.html#netket.sampler.MetropolisExchange">[docs]</a><span class="nd">@wraps_legacy</span><span class="p">(</span><span class="n">LegacyMetropolisExchange</span><span class="p">,</span> <span class="s2">&quot;machine&quot;</span><span class="p">,</span> <span class="n">AbstractMachine</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">MetropolisExchange</span><span class="p">(</span>
    <span class="n">hilbert</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MetropolisSampler</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This sampler acts locally only on two local degree of freedom :math:`s_i` and :math:`s_j`,</span>
<span class="sd">    and proposes a new state: :math:`s_1 \dots s^\prime_i \dots s^\prime_j \dots s_N`,</span>
<span class="sd">    where in general :math:`s^\prime_i \neq s_i` and :math:`s^\prime_j \neq s_j`.</span>
<span class="sd">    The sites :math:`i` and :math:`j` are also chosen to be within a maximum graph</span>
<span class="sd">    distance of :math:`d_{\mathrm{max}}`.</span>

<span class="sd">    The transition probability associated to this sampler can</span>
<span class="sd">    be decomposed into two steps:</span>

<span class="sd">    1. A pair of indices :math:`i,j = 1\dots N`, and such that</span>
<span class="sd">       :math:`\mathrm{dist}(i,j) \leq d_{\mathrm{max}}`,</span>
<span class="sd">       is chosen with uniform probability.</span>

<span class="sd">    2. The sites are exchanged, i.e. :math:`s^\prime_i = s_j` and :math:`s^\prime_j = s_i`.</span>


<span class="sd">    Notice that this sampling method generates random permutations of the quantum</span>
<span class="sd">    numbers, thus global quantities such as the sum of the local quantum numbers</span>
<span class="sd">    are conserved during the sampling.</span>
<span class="sd">    This scheme should be used then only when sampling in a</span>
<span class="sd">    region where :math:`\sum_i s_i = \mathrm{constant} ` is needed,</span>
<span class="sd">    otherwise the sampling would be strongly not ergodic.</span>

<span class="sd">    Args:</span>
<span class="sd">        hilbert: The hilbert space to sample</span>
<span class="sd">        d_max: The maximum graph distance allowed for exchanges.</span>
<span class="sd">        n_chains: The number of Markov Chain to be run in parallel on a single process.</span>
<span class="sd">        n_sweeps: The number of exchanges that compose a single sweep.</span>
<span class="sd">                If None, sweep_size is equal to the number of degrees of freedom being sampled</span>
<span class="sd">                (the size of the input vector s to the machine).</span>
<span class="sd">        n_batches: The number of batches of the states to sample (default = 8)</span>
<span class="sd">        machine_pow: The power to which the machine should be exponentiated to generate the pdf (default = 2).</span>
<span class="sd">        dtype: The dtype of the statees sampled (default = np.float32).</span>


<span class="sd">    Examples:</span>
<span class="sd">          Sampling from a RBM machine in a 1D lattice of spin 1/2, using</span>
<span class="sd">          nearest-neighbours exchanges.</span>

<span class="sd">          &gt;&gt;&gt; import netket as nk</span>
<span class="sd">          &gt;&gt;&gt;</span>
<span class="sd">          &gt;&gt;&gt; g=nk.graph.Hypercube(length=10,n_dim=2,pbc=True)</span>
<span class="sd">          &gt;&gt;&gt; hi=nk.hilbert.Spin(s=0.5,graph=g)</span>
<span class="sd">          &gt;&gt;&gt;</span>
<span class="sd">          &gt;&gt;&gt; # RBM Spin Machine</span>
<span class="sd">          &gt;&gt;&gt; ma = nk.machine.RbmSpin(alpha=1, hilbert=hi)</span>
<span class="sd">          &gt;&gt;&gt;</span>
<span class="sd">          &gt;&gt;&gt; # Construct a MetropolisExchange Sampler</span>
<span class="sd">          &gt;&gt;&gt; sa = nk.sampler.MetropolisExchange(machine=ma)</span>
<span class="sd">          &gt;&gt;&gt; print(sa.machine.hilbert.size)</span>
<span class="sd">          100</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">ExchangeRule</span><span class="p">(</span><span class="n">clusters</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">d_max</span><span class="o">=</span><span class="n">d_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MetropolisSampler</span><span class="p">(</span><span class="n">hilbert</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">.rules</span> <span class="kn">import</span> <span class="n">HamiltonianRule</span>
<span class="kn">from</span> <span class="nn">netket.legacy.sampler</span> <span class="kn">import</span> <span class="n">MetropolisHamiltonian</span> <span class="k">as</span> <span class="n">LegacyMetropolisHamiltonian</span>


<div class="viewcode-block" id="MetropolisHamiltonian"><a class="viewcode-back" href="../../../docs/_generated/samplers/netket.sampler.MetropolisHamiltonian.html#netket.sampler.MetropolisHamiltonian">[docs]</a><span class="nd">@wraps_legacy</span><span class="p">(</span><span class="n">LegacyMetropolisHamiltonian</span><span class="p">,</span> <span class="s2">&quot;machine&quot;</span><span class="p">,</span> <span class="n">AbstractMachine</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">MetropolisHamiltonian</span><span class="p">(</span><span class="n">hilbert</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MetropolisSampler</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sampling based on the off-diagonal elements of a Hamiltonian (or a generic Operator).</span>
<span class="sd">    In this case, the transition matrix is taken to be:</span>

<span class="sd">    .. math::</span>
<span class="sd">       T( \mathbf{s} \rightarrow \mathbf{s}^\prime) = \frac{1}{\mathcal{N}(\mathbf{s})}\theta(|H_{\mathbf{s},\mathbf{s}^\prime}|),</span>

<span class="sd">    where :math:`\theta(x)` is the Heaviside step function, and :math:`\mathcal{N}(\mathbf{s})`</span>
<span class="sd">    is a state-dependent normalization.</span>
<span class="sd">    The effect of this transition probability is then to connect (with uniform probability)</span>
<span class="sd">    a given state :math:`\mathbf{s}` to all those states :math:`\mathbf{s}^\prime` for which the Hamiltonian has</span>
<span class="sd">    finite matrix elements.</span>
<span class="sd">    Notice that this sampler preserves by construction all the symmetries</span>
<span class="sd">    of the Hamiltonian. This is in generally not true for the local samplers instead.</span>

<span class="sd">    This sampler only works on the CPU. To use the Hamiltonian smapler with GPUs,</span>
<span class="sd">    you should use :class:`netket.sampler.MetropolisHamiltonianNumpy`</span>

<span class="sd">    Args:</span>
<span class="sd">       machine: A machine :math:`\Psi(s)` used for the sampling.</span>
<span class="sd">                The probability distribution being sampled</span>
<span class="sd">                from is :math:`F(\Psi(s))`, where the function</span>
<span class="sd">                :math:`F(X)`, is arbitrary, by default :math:`F(X)=|X|^2`.</span>
<span class="sd">       hamiltonian: The operator used to perform off-diagonal transition.</span>
<span class="sd">       n_chains: The number of Markov Chain to be run in parallel on a single process.</span>
<span class="sd">       sweep_size: The number of exchanges that compose a single sweep.</span>
<span class="sd">                   If None, sweep_size is equal to the number of degrees of freedom (n_visible).</span>


<span class="sd">    Examples:</span>
<span class="sd">       Sampling from a RBM machine in a 1D lattice of spin 1/2</span>

<span class="sd">       &gt;&gt;&gt; import netket as nk</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; g=nk.graph.Hypercube(length=10,n_dim=2,pbc=True)</span>
<span class="sd">       &gt;&gt;&gt; hi=nk.hilbert.Spin(s=0.5,graph=g)</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; # RBM Spin Machine</span>
<span class="sd">       &gt;&gt;&gt; ma = nk.machine.RbmSpin(alpha=1, hilbert=hi)</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; # Transverse-field Ising Hamiltonian</span>
<span class="sd">       &gt;&gt;&gt; ha = nk.operator.Ising(hilbert=hi, h=1.0)</span>
<span class="sd">       &gt;&gt;&gt;</span>
<span class="sd">       &gt;&gt;&gt; # Construct a MetropolisHamiltonian Sampler</span>
<span class="sd">       &gt;&gt;&gt; sa = nk.sampler.MetropolisHamiltonian(machine=ma,hamiltonian=ha)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rule</span> <span class="o">=</span> <span class="n">HamiltonianRule</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MetropolisSampler</span><span class="p">(</span><span class="n">hilbert</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</pre></div>

    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2019-2021, The Netket authors - All rights reserved.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.3.<br/>
    </p>
  </div>
</footer>

<script type="text/javascript">
    jQuery(function () {
        SphinxRtdTheme.Navigation.enable(true);
      })
</script>

<!-- Temporary footer
<div class="footer-wip">
  <div class="footer-wip-content">
    This documentation refers to an unreleased version of Netket.
  </div>
</div>
-->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-118013987-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-118013987-1');
</script>

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "url": "https://www.netket.org",
  "name": "NetKet",
  "founder": "Giuseppe Carleo",
  "foundingDate": "2018-04-24",
  "foundingLocation" : "New York",
  "logo": "https://www.netket.org/img/logo_small.jpg",
  "sameAs": [
    "https://twitter.com/NetKetOrg",
    "https://github.com/NetKet/netket"
  ],
  "description" : "Netket is an open-source project delivering cutting-edge
  methods for the study of many-body quantum systems with artificial neural
  networks and machine learning techniques."
}
</script>

  </body>
</html>